<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue是如何收集依赖的</title>
    <link href="/2023/10/12/vue-dep/"/>
    <url>/2023/10/12/vue-dep/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文从源码层面进行分析，结合了实际<code>vue</code>项目经验，梳理<code>vue</code>的依赖收集，分析的<code>vue</code>版本为<code>3.3.3</code><br>本文适合有一定实战经验或阅读经验的<code>vue</code>开发者</p></blockquote><h2 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h2><p>在了解依赖收集前，我们先了解下<code>vue</code>是如何书写响应式的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 模板代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>count：&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>data：&#123;&#123; data.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 脚本代码</span><br><span class="hljs-comment">// ==============</span><br><span class="hljs-comment">// 1. `ref`对象是可变的</span><br><span class="hljs-comment">// 2. 任何`.value`的读操作都会被追踪</span><br><span class="hljs-comment">// 3. 任何`.value`的写操作都会触发关联的副作用</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>count.<span class="hljs-property">value</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 1. 深层的：响应式会去覆盖所有的可嵌套属性</span><br><span class="hljs-comment">// 2. 如果属性本身是响应式的，响应式覆盖将被忽略</span><br><span class="hljs-comment">// 3. 原生的集合类型(Map、Array、Set)等，响应式覆盖将被忽略</span><br><span class="hljs-comment">// 4. 传入的对象将被包裹`ES Proxy`</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>&#125;)<br>data.<span class="hljs-property">count</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="ref响应式源码分析"><a href="#ref响应式源码分析" class="headerlink" title="ref响应式源码分析"></a><code>ref</code>响应式源码分析</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params">value?: <span class="hljs-built_in">unknown</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRef</span>(value, <span class="hljs-literal">false</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowRef</span>(<span class="hljs-params">value?: <span class="hljs-built_in">unknown</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRef</span>(value, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRef</span>(<span class="hljs-params">rawValue: <span class="hljs-built_in">unknown</span>, shallow: <span class="hljs-built_in">boolean</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(rawValue)) &#123;<br>    <span class="hljs-keyword">return</span> rawValue<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefImpl</span>(rawValue, shallow)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefImpl</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_value</span>: T<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_rawValue</span>: T<br><br>  <span class="hljs-comment">// Set&lt;ReactiveEffect&gt;(effects?) 依赖集合，保存在响应式对象中</span><br>  <span class="hljs-keyword">public</span> dep?: <span class="hljs-title class_">Dep</span> = <span class="hljs-literal">undefined</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> __v_isRef = <span class="hljs-literal">true</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: T, <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> __v_isShallow: <span class="hljs-built_in">boolean</span></span>) &#123;<br>    <span class="hljs-comment">// toRaw: 返回原始对象，非响应式对象直接返回，响应式对象将返回原始对象(递归操作)</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rawValue</span> = __v_isShallow ? value : <span class="hljs-title function_">toRaw</span>(value)<br>    <span class="hljs-comment">// toReactive: return isObject(value) ? reactive(value) : value</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = __v_isShallow ? value : <span class="hljs-title function_">toReactive</span>(value)<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-title function_">trackRefValue</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 最终调用 trackEffects(ref.dep || (ref.dep = createDep()))</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span><br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newVal</span>) &#123;<br>    <span class="hljs-keyword">const</span> useDirectValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__v_isShallow</span> || <span class="hljs-title function_">isShallow</span>(newVal) || <span class="hljs-title function_">isReadonly</span>(newVal)<br>    newVal = useDirectValue ? newVal : <span class="hljs-title function_">toRaw</span>(newVal)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasChanged</span>(newVal, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rawValue</span>)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rawValue</span> = newVal<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = useDirectValue ? newVal : <span class="hljs-title function_">toReactive</span>(newVal)<br>      <span class="hljs-title function_">triggerRefValue</span>(<span class="hljs-variable language_">this</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>ref</code>读操作的时候会调用<code>trackRefValue</code>，最终调用<code>trackEffects</code>进行依赖收集<br>另一方面，依赖收集只会存在在<code>watch</code>、<code>computed</code>、<code>template bind</code>等进行(<code>watchEffect</code>)</p>]]></content>
    
    
    <categories>
      
      <category>前端深入浅出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Monorepo及其相关工具</title>
    <link href="/2023/08/18/monorepo-pnpm/"/>
    <url>/2023/08/18/monorepo-pnpm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Monorepo已经成为一种常见的项目管理策略，它允许开发者在一个集中的代码库中管理和维护多个项目。<br>本次技术分享将介绍Monorepo的概念，通过常见的前端项目管理痛点，讲解monorepo的解决方案，以及如何使用Lerna和Nx等工具实现Monorepo管理。</p></blockquote><h3 id="项目代码仓库管理策略的演进"><a href="#项目代码仓库管理策略的演进" class="headerlink" title="项目代码仓库管理策略的演进"></a>项目代码仓库管理策略的演进</h3><p>前端从最初的三剑客（HTML、CSS、JavaScript）到现在的各种框架、库、工具的百花齐放，前端项目的代码量也越来越多。在项目代码量不断增大的情况下，项目代码仓库的管理策略也在不断演进。目前比较流行的代码仓库管理策略有：</p><ol><li><code>Monolith</code> 策略： 流行于三剑客时代，前后端代码统一放在一个代码仓库中，前端代码和后端代码共同维护，形成一个巨石单体应用</li><li><code>Multi-repo</code> 策略：前后端分离时代，组件库、模块库、工具库等公共依赖会单独建立一个代码仓库，前端项目也会按照业务进行拆分成多个代码仓库，通过包管理工具(<code>npm</code>,<code>yarn</code>,<code>pnpm</code>)来实现项目对公共库的依赖</li><li><code>Mono-repo</code> 策略：微前端、微模块时代，多个业务项目最终会组合形成单一应用，公共库和项目库统一管理，公共库的升级消除了滞后性，项目库之间存在的公共代码公共模块可以及时的拆离出来，具有清晰的依赖关系，同时项目的代码风格、版本管理、提交规范、CI&#x2F;CD、测试、部署等也可以得到更好的统一管理</li></ol><p><img src="/images/monorepo-pnpm/evolution.png" alt="evolution"></p><h3 id="实战讲解"><a href="#实战讲解" class="headerlink" title="实战讲解"></a>实战讲解</h3><p>实现monorepo的方案有很多，这里我们介绍两种比较流行的方案：</p><p><img src="/images/monorepo-pnpm/project.png" alt="evolution"></p><h4 id="pnpm实现Monorepo"><a href="#pnpm实现Monorepo" class="headerlink" title="pnpm实现Monorepo"></a><code>pnpm</code>实现<code>Monorepo</code></h4><p><code>pnpm</code>特性里面有<code>Workspace</code>，我们可以通过这个特性来实现<code>Monorepo</code>。</p><ol><li>创建一个<code>monorepo</code>项目，初始化<code>pnpm</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir monorepo<br>cd monorepo<br>pnpm init<br></code></pre></td></tr></table></figure></li><li>创建<code>pnpm-workspace.yaml</code>文件<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ./pnpm-workspace.yaml</span><br><span class="hljs-attr">packages:</span><br>  <span class="hljs-comment"># 项目目录</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;packages/*&#x27;</span><br>  <span class="hljs-comment"># 公共库目录</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;components/**&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;api/**&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;modules/**&#x27;</span><br>  <span class="hljs-comment"># 排除测试目录中的文件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;!**/test/**&#x27;</span><br></code></pre></td></tr></table></figure></li><li>创建公共库和项目目录，并通过<code>pnpm</code>初始化<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> packages components api modules<br><span class="hljs-comment"># 初始化公共库目录</span><br><span class="hljs-built_in">cd</span> components<br>pnpm init<br><span class="hljs-comment"># 初始化项目目录</span><br><span class="hljs-built_in">mkdir</span> packages/project-&#123;a,b,c&#125;<br><span class="hljs-built_in">cd</span> packages/project-a<br>pnpm init<br></code></pre></td></tr></table></figure></li><li>修改<code>package.json</code>文件中的<code>name</code>字段，为了方便管理，可以统一加上<code>@monorepo</code>前缀<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@monorepo/modules&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>构建依赖关系<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 公共库之间的依赖</span><br><span class="hljs-built_in">cd</span> modules<br>pnpm add @monorepo/api<br><span class="hljs-comment"># 项目依赖</span><br><span class="hljs-comment"># project-&#123;a,b&#125;依赖公共库</span><br><span class="hljs-built_in">cd</span> packages/project-a<br>pnpm add @monorepo/api @monorepo/modules @monorepo/components<br><span class="hljs-built_in">cd</span> packages/project-b<br>pnpm add @monorepo/api @monorepo/modules @monorepo/components<br><span class="hljs-comment"># project-c依赖project-a和project-b</span><br><span class="hljs-built_in">cd</span> packages/project-c<br>pnpm add @monorepo/project-a @monorepo/project-b<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 安装完后的packages/project-a/package.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@monorepo/api&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;workspace:^&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@monorepo/components&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;workspace:^&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@monorepo/modules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;workspace:^&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>实例测试<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// api/user.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;male&#x27;</span> | <span class="hljs-string">&#x27;female&#x27;</span> &#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUserList</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>[]&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> (&#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;name&#x27;</span> + i,<br>                    <span class="hljs-attr">age</span>: i,<br>                    <span class="hljs-attr">sex</span>: (i &amp; <span class="hljs-number">1</span>) === <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;male&#x27;</span> : <span class="hljs-string">&#x27;female&#x27;</span>,<br>                &#125;))<br>            );<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;;<br><br><span class="hljs-comment">// api/index.ts</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user&#x27;</span><br><br><span class="hljs-comment">// package/project-a setup</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; fetchUserList, <span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@monorepo/api&#x27;</span><br><span class="hljs-keyword">const</span> user = ref&lt;<span class="hljs-title class_">User</span>[]&gt;([])<br><span class="hljs-title function_">fetchUserList</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">list</span>)=&gt;</span>&#123;<br>  user.<span class="hljs-property">value</span> = list<br>&#125;)<br></code></pre></td></tr></table></figure></li><li>项目构建部署<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># package/project-a</span><br>pnpm run build<br><span class="hljs-comment"># 构建后进入dist目录，模拟服务启动</span><br><span class="hljs-built_in">cd</span> dist<br><span class="hljs-comment"># 本地启动服务</span><br>live-server<br></code></pre></td></tr></table></figure></li></ol><p>我们已经通过<code>pnpm</code>的<code>Workspace</code>实现了<code>Monorepo</code>。<br>同时我们仍旧面临使用体验的问题，每次构建项目都需要在项目中执行构建命令(当然也可以通过脚本自动实现)，这对于开发、测试、部署、CI&#x2F;CD等都难以管理<br>针对上面的问题，我们可以使用<code>Lerna</code>工具，统一管理<code>script</code>指令</p><h4 id="Lerna工具使用"><a href="#Lerna工具使用" class="headerlink" title="Lerna工具使用"></a><code>Lerna</code>工具使用</h4><p><code>lerna</code>可以很好的结合<code>pnpm</code>，利用各自的优势更好的实现项目管理</p><ol><li>安装<code>Lerna</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add -w -D lerna<br><span class="hljs-comment"># 初始化</span><br>pnpm lerna init<br>pnpm lerna changed --all<br><span class="hljs-comment"># 输出项目中的packages</span><br>pnpm lerna list<br></code></pre></td></tr></table></figure></li><li>执行后会生成<code>lerna.json</code>文件<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node_modules/lerna/schemas/lerna-schema.json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;npmClient&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pnpm&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>统一管理<code>script</code>命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这时候可以在根目录构建project-a</span><br>pnpm lerna run --scope project-a build<br><span class="hljs-comment"># pnpm lerna run --scope project-a dev</span><br></code></pre></td></tr></table></figure></li></ol><p>目前我们已经实现了<code>script</code>命令中心化管理。</p><h4 id="Nx工具使用"><a href="#Nx工具使用" class="headerlink" title="Nx工具使用"></a><code>Nx</code>工具使用</h4><p><code>Nx</code>是一个由前<code>Google</code>员工开发的构建系统，它利用了<code>Google</code>内部工具所使用的许多技术。我们可以利用<code>Nx</code>来解决以下问题：</p><ol><li><p>代码生成</p></li><li><p>以<code>task</code>的形式管理脚本</p></li><li><p>管理、缓存、分发<code>task</code></p></li><li><p>Nx Console —— VS Code 插件</p></li><li><p>安装<code>Nx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add -w -D nx@latest<br></code></pre></td></tr></table></figure></li><li><p>展示项目依赖关系图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm nx graph<br></code></pre></td></tr></table></figure><p><img src="/images/monorepo-pnpm/graph.png" alt="graph"></p></li><li><p>代码生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装Nx插件</span><br>pnpm add -w -D @nx/plugin@latest<br><span class="hljs-comment"># 创建项目插件</span><br>pnpm nx g @nx/plugin:plugin my-plugin<br><span class="hljs-comment"># 生成generator</span><br>pnpm nx generate @nx/plugin:generator my-generator --project=my-plugin<br><span class="hljs-comment"># 在需要代码生成的项目里面执行</span><br>pnpm add @monorepo/my-plugin<br><span class="hljs-comment"># 通过模板生成代码</span><br>pnpm nx generate @monorepo/my-plugin:my-generator button<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>monorepo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PNPM是什么以及为什么前端开发者应该尝试使用它</title>
    <link href="/2023/08/18/pnpm/"/>
    <url>/2023/08/18/pnpm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是<a href="https://javascript.plainenglish.io/what-is-pnpm-why-you-should-try-it-as-a-frontend-developer-69a3a7b34f5b">《What is PNPM &amp; Why You Should Try It As a Frontend Developer》</a>的对照翻译</p></blockquote><p>了解 pnpm——<code>npm/yarn</code>的替代方案，了解其优点、依赖管理和用法。</p><p>前置疑问：为什么使用 PNPM，它有哪些学习点？</p><h2 id="什么是-pnpm"><a href="#什么是-pnpm" class="headerlink" title="什么是 pnpm?"></a>什么是 pnpm?</h2><p>正如<a href="https://pnpm.io/zh/">官网</a>所说，<strong>快速的，节省磁盘空间的包管理工具</strong></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>快速的</li></ol><p>以下是几个工具的比较：</p><p>可以看出，在大多数情况下，pnpm 作为黄色部分，包安装速度明显优于<code>npm/yarn</code>，速度会比<code>npm/yarn</code>快 2 倍。</p><table><thead><tr><th>action</th><th>cache</th><th>lockfile</th><th>node_modules</th><th>npm</th><th>pnpm</th><th>Yarn</th><th>Yarn PnP</th></tr></thead><tbody><tr><td>install</td><td></td><td></td><td></td><td>37.7s</td><td>19.3s</td><td>22.1s</td><td>20.2s</td></tr><tr><td>install</td><td>✔</td><td>✔</td><td>✔</td><td>2s</td><td>1.6s</td><td>695ms</td><td>n&#x2F;a</td></tr><tr><td>install</td><td>✔</td><td>✔</td><td></td><td>8.9s</td><td>5.1s</td><td>8.8s</td><td>668ms</td></tr><tr><td>install</td><td>✔</td><td></td><td></td><td>13.7s</td><td>8.6s</td><td>22.8s</td><td>15.2s</td></tr><tr><td>install</td><td></td><td>✔</td><td></td><td>14.2s</td><td>16.8s</td><td>8.9s</td><td>670ms</td></tr><tr><td>install</td><td>✔</td><td></td><td>✔</td><td>2.4s</td><td>3.9s</td><td>16s</td><td>n&#x2F;a</td></tr><tr><td>install</td><td></td><td>✔</td><td>✔</td><td>2s</td><td>1.6s</td><td>681ms</td><td>n&#x2F;a</td></tr><tr><td>install</td><td></td><td></td><td>✔</td><td>2.3s</td><td>15.2s</td><td>16.6s</td><td>n&#x2F;a</td></tr><tr><td>update</td><td>n&#x2F;a</td><td>n&#x2F;a</td><td>n&#x2F;a</td><td>8.9s</td><td>8s</td><td>8.7s</td><td>16.9s</td></tr></tbody></table><p><img src="/images/pnpm/alotta-files.svg" alt="Benchmarks"></p><p>总体而言，<code>pnpm</code>的包安装速度仍然明显优于 yarn。</p><ol start="2"><li>节省磁盘空间</li></ol><p>在内部管理中，<code>pnpm</code>使用内容可寻址的文件系统来存储磁盘上的所有文件。这个文件系统的优点是：</p><p>相同的包不会重复安装。当使用<code>npm/yarn</code>时，如果有 1000 个项目依赖于<code>lodash</code>，那么<code>lodash</code>可能会被安装 1000 次，并且这部分代码会在磁盘上被写入 1000 个地方。然而，当使用<code>pnpm</code>时，它只会安装一次，并且只在磁盘上写入一个地方。如果你再次使用它，你将会直接使用硬链接。</p><p>即使对于不同版本的包，<code>pnpm</code>也能够大大重用之前版本的代码。例如，如果<code>lodash</code>有 1000 个文件，并且在更新版本之后又增加了一个文件，那么磁盘将不会重写 1001 个文件，而是保留原来的 1000 个文件的硬链接，只写入新的一个文件。</p><ol start="3"><li>安全性高</li></ol><p>在使用<code>npm/yarn</code>之前，由于 node_module 的扁平结构，如果<code>A</code>依赖于<code>B</code>，<code>B</code>依赖于<code>C</code>，则<code>A</code>可以直接使用<code>C</code>，但问题是<code>A</code>没有声明<code>C</code>作为依赖项。因此，会出现这种非法访问的情况。然而，<code>pnpm</code>有非常大的“大脑洞”，并创建了一套依赖项管理方法，很好地解决了这个问题，并确保了安全性。</p><h2 id="pnpm依赖管理"><a href="#pnpm依赖管理" class="headerlink" title="pnpm依赖管理"></a><code>pnpm</code>依赖管理</h2><p>回顾一下<code>npm/yarn</code>为什么想要扁平化<code>node_modules</code>，难道不是因为相同的依赖项会被复制多次，路径也变得太长了吗？</p><p>如果你不复制文件，比如通过链接来替代呢？</p><p>首先，我将介绍链接，即软链接和硬链接。这是操作系统提供的机制。硬链接是同一文件的多个引用，而软链接则是创建一个新的文件，该文件的内容指向另一个路径。当然，这两种链接的使用方式是相似的。</p><p>如果你不复制文件，只需将<code>npm</code>包的内容保存在全局仓库中，然后将其他地方都链接起来。</p><p>这样，就不会有多个拷贝导致的浪费磁盘空间的问题，也不会有路径过长的问题。因为路径过长的主要限制是目录层次结构不能太深，现在每个位置的目录都是链接，而不是同一个目录，所以没有长度限制。</p><p>没错，<code>pnpm</code>就是通过这个想法实现的。</p><p>然后删除 node_modules，然后使用<code>pnpm</code>重新安装它，并执行<code>pnpm install</code>。</p><p>你会发现它打印出这句话：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pnpm install<br></code></pre></td></tr></table></figure><p><img src="/images/pnpm/1_IxAcMI5AHQqvpKu0J_2RaQ.webp" alt="output"><br>展开<code>.pnpm</code>文件夹可以看待<br><img src="/images/pnpm/1_Cewnyamzt3myXhsMe8PiiA.webp" alt=".pnpm"><br>所有依赖项都布局在这里，通过全局存储硬连接，然后通过软链接组织包到包的依赖项。<br>例如，在.pnpm 下的 express，这些是软链接<br><img src="/images/pnpm/1_HiWI8PDjCOC3tXpIxs1UCA.webp" alt=".pnpm"><br>也就是说，所有依赖项都从全局存储硬链接到 node_modules&#x2F;.pnpm，然后通过软链接相互依赖。</p><p>官方提供了一个示意图，您可以一起查看以理解它：<br><img src="/images/pnpm/1_KiXOhjIsgvXEKoWkWMQ8eA.webp" alt=".pnpm"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="pnpm-install"><a href="#pnpm-install" class="headerlink" title="pnpm install"></a>pnpm install</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Install axios</span><br>pnpm install axios<br><span class="hljs-comment"># Install axios and add axios to devDependencies</span><br>pnpm install axios -D<br><span class="hljs-comment"># Install axios and add axios to dependencies</span><br>pnpm install axios -S<br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>感谢谢阅读</strong>，我期待着您的关注和阅读更多高质量的文章。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang实现任务池管理器</title>
    <link href="/2023/08/16/task-pool-go/"/>
    <url>/2023/08/16/task-pool-go/</url>
    
    <content type="html"><![CDATA[<p>任务池管理器可以管理任务的调度和执行，控制并发执行的任务数量，支持动态任务添加，并在任务池为空时节省计算资源。这样可以有效地管理任务的执行，提高系统的性能和资源利用率。</p><p>项目中需要控制并发，因此需要实现一个任务池管理器，其必须具有以下作用：</p><ol><li><p>任务调度：任务池管理器可以接收并存储任务，并根据一定的调度策略从任务池中选择任务进行执行。在示例代码中，执行器每隔一秒从任务池中取出3个任务依次执行，保持了任务的顺序一致性。</p></li><li><p>资源控制：任务池管理器可以限制并发执行的任务数量。在示例代码中，通过控制执行器每次从任务池中取出的任务数量，可以控制并发执行的任务数量。这样可以避免系统资源被过度占用，提高系统的稳定性。</p></li><li><p>动态任务添加：任务池管理器支持动态添加任务。在示例代码中，通过调用 AddTask 方法可以将任务添加到任务池中。添加任务时，如果执行器没有启动，则会启动执行器。</p></li><li><p>节省计算资源：当任务池为空时，执行器会节省计算资源。在示例代码中，当任务池为空时，执行器会暂停执行，并在有新任务添加到任务池时重新启动执行器。</p></li></ol><h2 id="定义任务池相关结构体"><a href="#定义任务池相关结构体" class="headerlink" title="定义任务池相关结构体"></a>定义任务池相关结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 任务结构体</span><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 任务池结构体</span><br><span class="hljs-keyword">type</span> TaskPool <span class="hljs-keyword">struct</span> &#123;<br>mu             sync.Mutex<br>tasks          []Task<br>defaultExecutor *Executor<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义任务池相关方法"><a href="#定义任务池相关方法" class="headerlink" title="定义任务池相关方法"></a>定义任务池相关方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化任务池</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTaskPool</span><span class="hljs-params">()</span></span> *TaskPool &#123;<br><span class="hljs-keyword">return</span> &amp;TaskPool&#123;&#125;<br>&#125;<br><span class="hljs-comment">// 添加任务到任务池</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tp *TaskPool)</span></span> AddTask(task Task) &#123;<br>tp.mu.Lock()<br><span class="hljs-keyword">defer</span> tp.mu.Unlock()<br><br>tp.tasks = <span class="hljs-built_in">append</span>(tp.tasks, task)<br><br>    <span class="hljs-comment">// 如果没有定义执行器，则创建一个默认执行器</span><br><span class="hljs-keyword">if</span> tp.defaultExecutor == <span class="hljs-literal">nil</span> &#123;<br>tp.defaultExecutor = NewExecutor()<br>&#125;<br>    <span class="hljs-comment">// 如果执行器没有运行，则启动执行器</span><br><span class="hljs-keyword">if</span> !tp.defaultExecutor.running &#123;<br>tp.defaultExecutor.Start(tp)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 获取任务池中的任务数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tp *TaskPool)</span></span> GetTaskCount() <span class="hljs-type">int</span> &#123;<br>tp.mu.Lock()<br><span class="hljs-keyword">defer</span> tp.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tp.tasks)<br>&#125;<br><br><span class="hljs-comment">// 获取任务池中的指定数量任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tp *TaskPool)</span></span> GetTasks(count <span class="hljs-type">int</span>) []Task &#123;<br>tp.mu.Lock()<br><span class="hljs-keyword">defer</span> tp.mu.Unlock()<br><br><span class="hljs-keyword">if</span> count &gt; <span class="hljs-built_in">len</span>(tp.tasks) &#123;<br>count = <span class="hljs-built_in">len</span>(tp.tasks)<br>&#125;<br><br>tasks := tp.tasks[:count]<br>tp.tasks = tp.tasks[count:]<br><br><span class="hljs-keyword">return</span> tasks<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义任务执行器结构体"><a href="#定义任务执行器结构体" class="headerlink" title="定义任务执行器结构体"></a>定义任务执行器结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 执行器结构体</span><br><span class="hljs-keyword">type</span> Executor <span class="hljs-keyword">struct</span> &#123;<br>running <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义执行器相关方法"><a href="#定义执行器相关方法" class="headerlink" title="定义执行器相关方法"></a>定义执行器相关方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化执行器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewExecutor</span><span class="hljs-params">()</span></span> *Executor &#123;<br><span class="hljs-keyword">return</span> &amp;Executor&#123;<br>running: <span class="hljs-literal">false</span>,<br>&#125;<br>&#125;<br><span class="hljs-comment">// 启动执行器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Executor)</span></span> Start(taskPool *TaskPool) &#123;<br><span class="hljs-keyword">if</span> e.running &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>e.running = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(taskPool.tasks) == <span class="hljs-number">0</span> &#123;<br>e.running = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>            <span class="hljs-comment">// 默认以3个任务分为一组</span><br>tasks := taskPool.GetTasks(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// taskPool.mu.Lock()</span><br><span class="hljs-keyword">for</span> _, task := <span class="hljs-keyword">range</span> tasks &#123;<br>e.executeTask(task)<br>&#125;<br><span class="hljs-comment">// taskPool.mu.Unlock()</span><br>time.Sleep(time.Second)<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-comment">// 执行任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Executor)</span></span> executeTask(task Task) &#123;<br><span class="hljs-comment">// 执行任务的逻辑</span><br>fmt.Printf(<span class="hljs-string">&quot;Executing task ID: %d, Name: %s\n&quot;</span>, task.ID, task.Name)<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 任务结构体</span><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 任务池结构体</span><br><span class="hljs-keyword">type</span> TaskPool <span class="hljs-keyword">struct</span> &#123;<br>mu             sync.Mutex<br>tasks          []Task<br>defaultExecutor *Executor<br>&#125;<br><br><span class="hljs-comment">// 执行器结构体</span><br><span class="hljs-keyword">type</span> Executor <span class="hljs-keyword">struct</span> &#123;<br>running <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// 初始化任务池</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTaskPool</span><span class="hljs-params">()</span></span> *TaskPool &#123;<br><span class="hljs-keyword">return</span> &amp;TaskPool&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 添加任务到任务池</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tp *TaskPool)</span></span> AddTask(task Task) &#123;<br>tp.mu.Lock()<br><span class="hljs-keyword">defer</span> tp.mu.Unlock()<br><br>tp.tasks = <span class="hljs-built_in">append</span>(tp.tasks, task)<br><br><span class="hljs-keyword">if</span> tp.defaultExecutor == <span class="hljs-literal">nil</span> &#123;<br>tp.defaultExecutor = NewExecutor()<br>&#125;<br><span class="hljs-keyword">if</span> !tp.defaultExecutor.running &#123;<br>tp.defaultExecutor.Start(tp)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 获取任务池中的任务数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tp *TaskPool)</span></span> GetTaskCount() <span class="hljs-type">int</span> &#123;<br>tp.mu.Lock()<br><span class="hljs-keyword">defer</span> tp.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tp.tasks)<br>&#125;<br><br><span class="hljs-comment">// 获取任务池中的指定数量任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tp *TaskPool)</span></span> GetTasks(count <span class="hljs-type">int</span>) []Task &#123;<br>tp.mu.Lock()<br><span class="hljs-keyword">defer</span> tp.mu.Unlock()<br><br><span class="hljs-keyword">if</span> count &gt; <span class="hljs-built_in">len</span>(tp.tasks) &#123;<br>count = <span class="hljs-built_in">len</span>(tp.tasks)<br>&#125;<br><br>tasks := tp.tasks[:count]<br>tp.tasks = tp.tasks[count:]<br><br><span class="hljs-keyword">return</span> tasks<br>&#125;<br><br><span class="hljs-comment">// 初始化执行器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewExecutor</span><span class="hljs-params">()</span></span> *Executor &#123;<br><span class="hljs-keyword">return</span> &amp;Executor&#123;<br>running: <span class="hljs-literal">false</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 启动执行器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Executor)</span></span> Start(taskPool *TaskPool) &#123;<br><span class="hljs-keyword">if</span> e.running &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>e.running = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(taskPool.tasks) == <span class="hljs-number">0</span> &#123;<br>e.running = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br><br>tasks := taskPool.GetTasks(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> _, task := <span class="hljs-keyword">range</span> tasks &#123;<br>e.executeTask(task)<br>&#125;<br><br>time.Sleep(time.Second)<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-comment">// 执行任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Executor)</span></span> executeTask(task Task) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Executing task ID: %d, Name: %s\n&quot;</span>, task.ID, task.Name)<br>time.Sleep(time.Second)<br><span class="hljs-comment">// 执行任务的逻辑</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>taskPool := NewTaskPool()<br><br><span class="hljs-comment">// 添加任务到任务池</span><br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">1</span>, Name: <span class="hljs-string">&quot;Task 1&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">2</span>, Name: <span class="hljs-string">&quot;Task 2&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">3</span>, Name: <span class="hljs-string">&quot;Task 3&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">4</span>, Name: <span class="hljs-string">&quot;Task 4&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">5</span>, Name: <span class="hljs-string">&quot;Task 5&quot;</span>&#125;)<br><br><span class="hljs-comment">// 添加更多任务到任务池</span><br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">6</span>, Name: <span class="hljs-string">&quot;Task 6&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">7</span>, Name: <span class="hljs-string">&quot;Task 7&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">8</span>, Name: <span class="hljs-string">&quot;Task 8&quot;</span>&#125;)<br><br><span class="hljs-comment">// 等待执行器完成任务</span><br>time.Sleep(<span class="hljs-number">15</span> * time.Second)<br><br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">6</span>, Name: <span class="hljs-string">&quot;Task 6&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">7</span>, Name: <span class="hljs-string">&quot;Task 7&quot;</span>&#125;)<br>taskPool.AddTask(Task&#123;ID: <span class="hljs-number">8</span>, Name: <span class="hljs-string">&quot;Task 8&quot;</span>&#125;)<br><br>time.Sleep(<span class="hljs-number">15</span> * time.Second)<br>&#125;<br><span class="hljs-comment">// Output</span><br><span class="hljs-comment">// Executing task ID: 1, Name: Task 1</span><br><span class="hljs-comment">// Executing task ID: 2, Name: Task 2</span><br><span class="hljs-comment">// Executing task ID: 3, Name: Task 3</span><br><span class="hljs-comment">// Executing task ID: 4, Name: Task 4</span><br><span class="hljs-comment">// Executing task ID: 5, Name: Task 5</span><br><span class="hljs-comment">// Executing task ID: 6, Name: Task 6</span><br><span class="hljs-comment">// Executing task ID: 7, Name: Task 7</span><br><span class="hljs-comment">// Executing task ID: 8, Name: Task 8</span><br><span class="hljs-comment">// Executing task ID: 6, Name: Task 6</span><br><span class="hljs-comment">// Executing task ID: 7, Name: Task 7</span><br><span class="hljs-comment">// Executing task ID: 8, Name: Task 8</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Golang</category>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>任务池</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git添加代理</title>
    <link href="/2023/08/09/git-slow/"/>
    <url>/2023/08/09/git-slow/</url>
    
    <content type="html"><![CDATA[<p><code>git</code>连接<code>github</code>会很慢，本文主要记录一些<code>git</code>添加代理的一些方式</p><h2 id="设置全局git代理"><a href="#设置全局git代理" class="headerlink" title="设置全局git代理"></a>设置全局<code>git</code>代理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global https.proxy http://127.0.0.1:1080<br><br>git config --global https.proxy https://127.0.0.1:1080<br></code></pre></td></tr></table></figure><h2 id="取消全局git代理"><a href="#取消全局git代理" class="headerlink" title="取消全局git代理"></a>取消全局<code>git</code>代理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br><br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><h2 id="单独为Github设置代理"><a href="#单独为Github设置代理" class="headerlink" title="单独为Github设置代理"></a>单独为<code>Github</code>设置代理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>git</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XY-Problem</title>
    <link href="/2023/08/09/XY-Problem/"/>
    <url>/2023/08/09/XY-Problem/</url>
    
    <content type="html"><![CDATA[<p>当你遇到一个问题，你首先想到的是如何解决它，而不是先思考为什么会出现这个问题。</p><h2 id="What-is-XY-Problem"><a href="#What-is-XY-Problem" class="headerlink" title="What is XY-Problem?"></a>What is XY-Problem?</h2><p>对于X-Y Problem的意思如下：</p><ol><li>有人想解决问题X</li><li>他觉得Y可能是解决X问题的方法</li><li>但是他不知道Y应该怎么做</li><li>于是他去问别人Y应该怎么做？</li></ol><p>简而言之，<strong>没有去问怎么解决问题X，而是去问解决方案Y应该怎么去实现和操作</strong>。于是乎：</p><ol><li>热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。</li><li>在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始的问题X是怎么一回事。</li><li>于是大家都发现，Y根本就不是用来解决X的合适的方案。</li></ol><p>X-Y Problem最大的严重的问题就是：<strong>在一个根本错误的方向上浪费他人大量的时间和精力！</strong></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><ol><li><p>大多数人有时候，非常容易把手段当目的，他们会用自己所喜欢的技术和方法来反推用户的需求，于是很有可能就会出现X-Y Problem – 也许解决用户需求最适合的技术方案是PC，但是我们要让他们用手机。</p></li><li><p>产品经理有时候并不清楚他想解决的用户需求是什么，于是他觉得可能开发Y的功能能够满足用户，于是他提出了Y的需求让技术人员去做，但那根本不是解决X问题的最佳方案。</p></li><li><p>因为公司或部门的一些战略安排，业务部门设计了相关的业务规划，然后这些业务规划更多的是公司想要的Y，而不是解决用户的X问题。</p></li><li><p>对于个人的职业发展，X是成长为有更强的技能和能力，这个可以拥有比别人更强的竞争力，从而可以有更好的报酬，但确走向了Y：全身心地追逐KPI。</p></li><li><p>本来我们想达成的X是做出更好和更有价值的产品，但最终走到了Y：通过各种手段提升安装量，点击量，在线量，用户量来衡量。</p></li><li><p>很多团队Leader都喜欢制造信息不平等，并不告诉团队某个事情的来由，掩盖X，而直接把要做的Y告诉团队，导致团队并不真正地理解，而产生了很多时间和经历的浪费。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>思维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题思维模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端修改国内源</title>
    <link href="/2023/08/04/mirror/"/>
    <url>/2023/08/04/mirror/</url>
    
    <content type="html"><![CDATA[<h2 id="npm-国内源"><a href="#npm-国内源" class="headerlink" title="npm 国内源"></a>npm 国内源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><h2 id="nvm-国内源"><a href="#nvm-国内源" class="headerlink" title="nvm 国内源"></a>nvm 国内源</h2><ul><li>设置npm_mirror:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nvm npm_mirror https://npmmirror.com/mirrors/npm/<br></code></pre></td></tr></table></figure></li><li>设置node_mirror:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nvm node_mirror https://npmmirror.com/mirrors/node/<br></code></pre></td></tr></table></figure></li></ul><h2 id="electron-国内源"><a href="#electron-国内源" class="headerlink" title="electron 国内源"></a>electron 国内源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># https://npmmirror.com/mirrors/electron/</span><br>npm config <span class="hljs-built_in">set</span> electron_mirror=https://npmmirror.com/mirrors/electron/<br>npm config <span class="hljs-built_in">set</span> electron_builder_binaries_mirror=https://npmmirror.com/mirrors/electron-builder-binaries/<br></code></pre></td></tr></table></figure><h2 id="镜像集合"><a href="#镜像集合" class="headerlink" title="镜像集合"></a>镜像集合</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># https://npmmirror.com/</span><br><span class="hljs-comment"># 开源镜像: https://npmmirror.com/mirrors/</span><br><span class="hljs-comment"># Node.js 镜像: https://npmmirror.com/mirrors/node/</span><br><span class="hljs-comment"># alinode 镜像: https://npmmirror.com/mirrors/alinode/</span><br><span class="hljs-comment"># ChromeDriver 镜像: https://npmmirror.com/mirrors/chromedriver/</span><br><span class="hljs-comment"># OperaDriver 镜像: https://npmmirror.com/mirrors/operadriver/</span><br><span class="hljs-comment"># Selenium 镜像: https://npmmirror.com/mirrors/selenium/</span><br><span class="hljs-comment"># electron 镜像: https://npmmirror.com/mirrors/electron/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>镜像</tag>
      
      <tag>国内源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2023/08/04/performance/"/>
    <url>/2023/08/04/performance/</url>
    
    <content type="html"><![CDATA[<p>性能优化的核心在于减少页面加载时间和提高用户体验</p><h2 id="Why-为什么需要性能优化"><a href="#Why-为什么需要性能优化" class="headerlink" title="Why-为什么需要性能优化"></a>Why-为什么需要性能优化</h2><p>性能优化在前端开发中非常重要，原因如下：</p><ol><li><p>提升用户体验：用户对于网页加载速度和响应性的要求越来越高。如果网页加载缓慢或响应不及时，用户可能会感到不耐烦，甚至选择离开。通过性能优化，可以加快网页的加载速度、提高响应性，提升用户体验，增加用户的留存和转化率。</p></li><li><p>提高页面可访问性：性能优化可以确保网页在不同网络环境和设备上都能快速加载和正确显示。对于网络条件较差或设备性能较低的用户，快速加载的网页可以提供更好的访问体验，降低用户的等待时间和流量消耗。</p></li><li><p>节省带宽和服务器资源：优化资源加载和压缩可以减少网页的文件大小和HTTP请求次数，从而节省带宽和服务器资源。这对于大流量网站来说尤为重要，可以降低服务器的负载，减少资源消耗和成本。</p></li><li><p>改善搜索引擎排名：搜索引擎对于网页加载速度的优化有一定的考量，加载速度较快的网页往往在搜索结果中排名更高。通过性能优化，可以提高网页的加载速度和性能表现，有助于改善搜索引擎的排名，增加网页的曝光和流量。</p></li><li><p>适应移动设备和低带宽环境：越来越多的用户使用移动设备访问网页，而移动设备的网络环境和性能有限。性能优化可以使网页适应不同的设备和网络环境，提供良好的移动端体验，满足用户的需求。</p></li></ol><p>综上所述，性能优化对于提升用户体验、节省资源、改善搜索排名和适应移动设备等方面都具有重要意义。它能够使网页加载更快、响应更快，提高用户满意度，增加网站的流量和转化率。</p><h2 id="What-前端性能优化究竟是什么"><a href="#What-前端性能优化究竟是什么" class="headerlink" title="What-前端性能优化究竟是什么"></a>What-前端性能优化究竟是什么</h2><p>性能优化是一种技术过程，通过一系列技术和策略来改善<code>前端</code>(网页或应用程序)的性能，以提高用户体验和效率，并解决以上问题。</p><h2 id="How-如何进行性能优化"><a href="#How-如何进行性能优化" class="headerlink" title="How-如何进行性能优化"></a>How-如何进行性能优化</h2><p>性能优化可以按照优化目的进行简单的分类</p><ol><li>资源下载速度<ol><li>减少源码包大小：<code>tree shaking</code>、<code>lazy load</code>，经常在打包工具的过程中进行优化</li><li>按优先度拆分资源包：将可以懒加载的资源从主包中拆分出来，降低主包的大小</li><li>服务器运用压缩技术：<code>Gzip</code>、<code>Br</code>等压缩</li><li><code>CDN</code>技术：运用<code>CDN</code>技术，将源码包部署到CDN服务器，加快资源的响应速度</li><li>充分利用缓存机制： 使用缓存可以减少请求开销，如使用 <code>Service Worker</code>，制定合理地 <code>HTTP Cache</code> 策略等</li></ol></li><li>渲染速度<ol><li>资源懒加载：图片、字体文件、字体图标等，可以按需加载</li><li>资源适配：根据机型适配合适大小的资源文件</li><li>避免频繁DOM操作：可以将多次的Dom操作合并，或者利用<code>Virtual DOM</code>技术</li></ol></li><li>执行速度<ol><li>减少不必要的计算和操作：避免进行不必要的计算和操作，尽量减少循环次数和条件判断。可以通过缓存计算结果、合并操作、使用短路运算符等方式来减少不必要的计算。</li><li>优化循环和迭代：循环是JavaScript中常见的性能瓶颈之一。可以使用更高效的循环方式，如使用for循环替代forEach、map等迭代方法。同时，在循环中避免频繁的DOM操作，可以将DOM操作移到循环外部或使用文档片段进行批量操作。</li><li>使用事件委托：对于需要处理大量相似元素的事件，可以使用事件委托的方式，将事件处理程序绑定到它们的父元素上，通过事件冒泡机制来处理事件。这样可以减少事件处理程序的数量，提高性能。</li><li>使用异步操作：对于耗时的操作，如网络请求、文件读写等，可以使用异步操作来避免阻塞主线程。可以使用Promise、async&#x2F;await、setTimeout等方式来进行异步操作。</li><li>使用Web Workers：对于需要进行大量计算或复杂操作的任务，可以考虑使用Web Workers。Web Workers可以在后台线程中执行任务，不会阻塞主线程，提高页面的响应性能。</li></ol></li></ol><h3 id="针对Vue框架的性能优化"><a href="#针对Vue框架的性能优化" class="headerlink" title="针对Vue框架的性能优化"></a>针对Vue框架的性能优化</h3><ol><li><p>升级到<code>Vue3</code>：<code>Vue3</code>在<code>diff算法</code>和<code>响应式</code>都进行了很大的性能优化，另外编程效率、团队协作效率在Vue也有很巨大的提升</p></li><li><p>缩小组件范围：在<code>Vue</code>应用程序中，组件是构建用户界面的基本单元。为了提高性能，可以尽量缩小组件的范围。将组件细分为更小的组件，避免不必要的重新渲染和更新。</p></li><li><p>合理使用计算属性和侦听器：计算属性和侦听器是Vue中用于处理响应式数据的机制。合理使用计算属性和侦听器可以避免不必要的计算和更新。确保计算属性是基于需要的响应式数据计算的，并避免在侦听器中执行复杂的操作。</p></li><li><p>合理使用<code>v-if</code>和<code>v-for</code>指令：<code>v-if</code>和<code>v-for</code>是<code>Vue</code>中常用的指令，用于条件渲染和列表渲染。在使用这些指令时，要注意避免在循环中使用<code>v-if</code>，因为它会导致不必要的重新渲染。可以考虑使用计算属性或过滤器来处理复杂的条件逻辑。</p></li><li><p>使用<code>Vue</code>的异步组件：<code>Vue</code>提供了异步组件的功能，可以延迟加载组件，提高初始渲染性能。可以将不常用或较大的组件设置为异步组件，只在需要时进行加载。</p></li><li><p>合理使用<code>keep-alive</code>组件：<code>keep-alive</code>组件可以缓存组件的状态，避免重复的创建和销毁。对于需要频繁切换的组件，可以使用<code>keep-alive</code>组件进行缓存，提高性能。</p></li><li><p>使用Vue的列表过渡和动画：<code>Vue</code>提供了列表过渡和动画的功能，可以为列表的插入、更新和删除操作添加过渡效果。合理使用这些过渡和动画可以提升用户体验，但要注意避免过多的动画效果影响性能。</p></li><li><p>懒加载路由和组件：对于大型的<code>Vue</code>应用程序，可以考虑使用懒加载路由和组件的方式。只在需要时加载路由和组件，减少初始加载的资源量。</p></li></ol><h3 id="针对Angular框架的性能优化"><a href="#针对Angular框架的性能优化" class="headerlink" title="针对Angular框架的性能优化"></a>针对Angular框架的性能优化</h3><ol><li><p>使用<code>AOT</code>编译：<code>Angular</code>提供了<code>AOT（Ahead-of-Time）</code>编译器，可以在构建时将模板编译为<code>JavaScript</code>代码。与<code>JIT（Just-in-Time）</code>编译相比，AOT编译可以减少应用程序的初始加载时间，并提高性能。</p></li><li><p>懒加载模块：对于大型的<code>Angular</code>应用程序，可以使用懒加载模块的方式延迟加载不必要的模块。只在需要时加载模块，可以减少初始加载的资源量，提高应用程序的加载速度。</p></li><li><p>使用轻量级的变更检测策略：<code>Angular</code>的变更检测机制是其性能的一个关键点。可以使用轻量级的变更检测策略，如OnPush策略，来减少变更检测的次数。在组件中设置<code>ChangeDetectionStrategy.OnPush</code>可以告诉<code>Angular</code>只在输入属性发生变化时才进行变更检测。</p></li><li><p>减少不必要的变更检测：在<code>Angular</code>应用程序中，避免在模板中使用复杂的表达式和函数调用，因为它们可能会触发不必要的变更检测。尽量将复杂的计算逻辑移到组件中，在需要时手动触发变更检测。</p></li><li><p>使用轻量级的<code>RxJS</code>操作符：<code>RxJS</code>是<code>Angular</code>中常用的响应式编程库。在使用<code>RxJS</code>时，尽量使用轻量级的操作符，如<code>map</code>、<code>filter</code>等，避免使用过多的操作符和复杂的管道，以减少性能开销。</p></li><li><p>避免频繁的<code>DOM操作</code>：频繁的<code>DOM操作</code>会影响性能。可以使用<code>Angular</code>的内置指令，如<code>ngIf</code>、<code>ngFor</code>等，来优化DOM操作。另外，可以使用<code>ng-container</code>来减少不必要的<code>DOM元素</code>嵌套。</p></li><li><p>使用轻量级的依赖注入：依赖注入是<code>Angular</code>的核心特性之一。在使用依赖注入时，尽量使用轻量级的服务和依赖项，避免注入过多的复杂对象和不必要的依赖。</p></li><li><p>使用<code>TrackBy</code>函数进行列表渲染优化：在使用<code>ngFor</code>指令进行列表渲染时，可以通过提供一个<code>TrackBy</code>函数来优化性能。TrackBy函数可以告诉<code>Angular</code>如何跟踪列表中的每个项的唯一标识，从而减少不必要的DOM操作。</p></li></ol><h3 id="针对React框架的性能优化"><a href="#针对React框架的性能优化" class="headerlink" title="针对React框架的性能优化"></a>针对React框架的性能优化</h3><ol><li><p>使用生产环境构建：在部署<code>React</code>应用程序时，使用生产环境构建可以进行代码压缩和优化，减少文件大小，提高加载速度。</p></li><li><p>使用<code>React.memo</code>进行组件记忆：<code>React.memo</code>是一个高阶组件，用于记忆组件的渲染结果。可以使用<code>React.memo</code>来避免不必要的组件重新渲染，提高性能。但要注意，<code>React.memo</code>只对组件的<code>props</code>进行浅比较，如果<code>props</code>包含复杂的对象或函数，可能需要额外的处理。</p></li><li><p>使用<code>React.lazy</code>和<code>Suspense</code>进行懒加载：<code>React.lazy</code>和<code>Suspense</code>是React提供的懒加载机制。可以将组件的加载延迟到需要时再进行，减少初始加载的资源量。使用<code>React.lazy</code>和<code>Suspense</code>可以实现按需加载组件，提高应用程序的性能。</p></li><li><p>使用<code>shouldComponentUpdate</code>或<code>React.memo</code>进行组件更新控制：在React中，可以使用<code>shouldComponentUpdate</code>生命周期方法或<code>React.memo</code>来控制组件的更新。通过实现自定义的<code>shouldComponentUpdate</code>方法或使用<code>React.memo</code>，可以避免不必要的组件重新渲染，提高性能。</p></li><li><p>使用<code>React.Fragment</code>减少不必要的DOM节点：在渲染组件时，可以使用<code>React.Fragment</code>来包裹多个子元素，以减少不必要的DOM节点。<code>React.Fragment</code>可以帮助优化DOM结构，提高渲染性能。</p></li><li><p>使用虚拟化列表：对于长列表或大数据集，可以使用虚拟化列表来渲染可见区域的内容。虚拟化列表只渲染当前可见的列表项，而不是全部渲染，从而减少DOM操作和提高性能。</p></li><li><p>使用轻量级的状态管理方案：对于中小型的React应用程序，可以考虑使用轻量级的状态管理方案，如<code>React Context</code>或<code>Redux Toolkit</code>。避免引入过多的状态管理库和复杂的状态管理逻辑，以减少性能开销。</p></li><li><p>使用性能优化工具和库：有许多第三方工具和库可用于优化React应用程序的性能，如<code>Webpack</code>的代码分割和懒加载插件、<code>React Router</code>的懒加载路由、<code>React.memo</code>的自定义比较函数等。根据具体的应用场景和需求，选择适合的工具和库进行性能优化。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端深入浅出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的事件循环机制</title>
    <link href="/2021/08/04/event-loop/"/>
    <url>/2021/08/04/event-loop/</url>
    
    <content type="html"><![CDATA[<p>事件循环机制的核心是一个事件循环线程，它持续运行并监听事件队列。当有事件需要处理时，事件循环会将事件从队列中取出并执行相应的回调函数</p><h2 id="Why-为什么需要事件循环机制"><a href="#Why-为什么需要事件循环机制" class="headerlink" title="Why-为什么需要事件循环机制"></a>Why-为什么需要事件循环机制</h2><p><code>JavaScript</code>是一种单线程的编程语言，意味着它一次只能执行一个任务。如果在执行一个耗时的操作时，如网络请求或计算密集型任务，如果<code>JavaScript</code>采用同步的方式执行，那么整个页面或应用程序将会被阻塞，用户无法进行其他操作，直到该任务完成。这会导致用户体验不佳，页面或应用程序的响应性能下降。</p><p>为了解决这个问题，<code>JavaScript</code>引入了事件循环机制。事件循环机制允许<code>JavaScript</code>在执行异步任务时，不必等待任务完成，而是继续执行后续的代码。它通过将异步任务放入任务队列中，并在主线程空闲时执行相应的回调函数，实现了非阻塞的异步执行。</p><p>具体来说，事件循环机制的好处包括：</p><ol><li>增强用户体验：通过使用事件循环机制，可以确保页面或应用程序的响应性能更高，用户可以在进行耗时操作时继续进行其他操作。</li><li>提高性能：通过将耗时的任务放入异步队列中，<code>JavaScript</code>可以继续执行其他任务，充分利用计算资源，提高整体性能。</li><li>处理事件和交互：事件循环机制使得<code>JavaScript</code>能够处理用户交互、事件监听和响应，例如点击事件、键盘事件和鼠标事件等。</li><li>支持异步操作：<code>JavaScript</code>中有许多常见的异步操作，如网络请求、文件读写和定时器等。事件循环机制使得这些异步操作可以以非阻塞的方式执行，提高代码的效率和可维护性。</li></ol><h2 id="What-事件循环究竟是什么"><a href="#What-事件循环究竟是什么" class="headerlink" title="What-事件循环究竟是什么"></a>What-事件循环究竟是什么</h2><p>在 JavaScript 中，异步任务可以分为<code>宏任务</code>和<code>微任务</code></p><p><code>宏任务</code>一般包括了以下几种：</p><ul><li><code>setTimeout</code> 和 <code>setInterval</code></li><li><code>I/O</code> 操作，如 <code>Ajax</code>、<code>文件读取</code>等</li><li><code>UI渲染</code>等</li></ul><p><code>微任务</code>一般包括以下几种：</p><ul><li><code>Promise.then()</code> 和 <code>catch()</code>方法</li><li><code>process.nextTick()</code></li><li><code>MutationObserver()</code>方法</li></ul><p><code>JavaScript</code> 中的事件循环机制由下面四个部分组成：</p><ol><li><p>调用堆栈(<code>Call Stack</code>)<br>调用堆栈记录了 <code>JavaScript</code> 代码的执行顺序。当代码开始执行时，会被顺序推入调用堆栈(<code>Call Stack</code>)，当函数执行完毕后，会从堆栈中弹出。由于 <code>JavaScript</code> 是单线程的，所以在调用堆栈中只能有一个任务在执行。在执行宏任务的过程中，如果遇到了微任务会将其加入微任务队列；</p></li><li><p>宏任务队列(<code>Task Queue</code>)<br>宏任务队列可以理解为存放宏任务的一个队列。当遇到宏任务时，它会被顺序加入到宏任务队列中。宏任务一般是异步任务，包括 <code>setTimeout</code> 、<code>setInterval</code>、<code>I/O 操作</code>等。只有当前的宏任务执行完毕之后，才会执行下一个宏任务。</p></li><li><p>微任务队列(<code>Microtask Queue</code>)<br>微任务队列也可以理解为存放微任务的一个队列。当遇到微任务时，它会被顺序加入到微任务队列中。在每个宏任务执行结束后，会检查微任务队列是否为空。如果不为空，就会执行微任务队列中的所有任务，直到微任务队列为空。</p></li><li><p>渲染队列(<code>Render Queue</code>)<br>渲染队列主要是用于浏览器中的渲染，保存了在执行宏任务期间发生的所有页面渲染操作，例如修改了 <code>DOM</code> 树中的节点内容。当宏任务执行完毕后，<code>JavaScript</code>引擎会检查是否需要更新页面，如果需要，则进行渲染，否则跳过这个步骤。</p></li></ol><h2 id="How-事件循环机制是如何执行的"><a href="#How-事件循环机制是如何执行的" class="headerlink" title="How-事件循环机制是如何执行的"></a>How-事件循环机制是如何执行的</h2><p>事件循环机制的执行过程可以分为以下几个步骤：</p><ol><li><p>执行同步代码：<code>JavaScript</code>首先会执行当前的同步代码，即按照顺序执行代码块中的语句，直到遇到异步任务或事件。</p></li><li><p>将异步任务放入任务队列：当遇到异步任务时，<code>JavaScript</code>会将其放入任务队列中，而不是立即执行。异步任务可以是定时器（<code>setTimeout</code>、<code>setInterval</code>）、网络请求（<code>Ajax</code>、<code>Fetch</code>）、<code>Promise</code>等。这些异步任务会在特定的条件满足后被触发执行。</p></li><li><p>监听事件队列：事件循环线程会持续监听事件队列，以检查是否有待处理的事件或异步任务。事件队列中存储了待处理的事件和异步任务。</p></li><li><p>执行事件处理或异步任务：当事件循环线程发现事件队列中有待处理的事件时，它会取出事件，并执行相应的事件处理函数。对于异步任务，当主线程空闲时，事件循环线程会从任务队列中取出任务，并执行相应的回调函数。</p></li><li><p>重复执行：一旦执行完一个事件处理或异步任务，事件循环线程会再次检查事件队列，看是否还有待处理的事件。如果有，它会继续执行下一个事件处理或异步任务。这个过程会一直重复，直到事件队列和任务队列都为空。</p></li></ol><p>需要注意的是，事件循环机制是单线程的，意味着同一时间只能执行一个任务。当事件循环线程执行事件处理或异步任务时，其他任务需要等待。这也是为什么长时间运行的任务可能会阻塞主线程，导致页面或应用程序的响应性能下降。</p><h2 id="Got-能从中收益什么"><a href="#Got-能从中收益什么" class="headerlink" title="Got-能从中收益什么"></a>Got-能从中收益什么</h2><p>通过事件循环机制，JavaScript能够以非阻塞的方式处理异步任务和事件，提高代码的执行效率和用户体验。了解事件循环机制的执行过程对于编写高效的异步代码非常重要，因为它可以帮助你理解代码执行的顺序和如何处理异步操作。</p>]]></content>
    
    
    <categories>
      
      <category>前端深入浅出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件循环</tag>
      
      <tag>EventLoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

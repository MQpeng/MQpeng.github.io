<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端修改国内源</title>
    <link href="/2023/08/04/mirror/"/>
    <url>/2023/08/04/mirror/</url>
    
    <content type="html"><![CDATA[<h2 id="npm-国内源"><a href="#npm-国内源" class="headerlink" title="npm 国内源"></a>npm 国内源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><h2 id="nvm-国内源"><a href="#nvm-国内源" class="headerlink" title="nvm 国内源"></a>nvm 国内源</h2><ul><li>设置npm_mirror:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nvm npm_mirror https://npmmirror.com/mirrors/npm/<br></code></pre></td></tr></table></figure></li><li>设置node_mirror:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nvm node_mirror https://npmmirror.com/mirrors/node/<br></code></pre></td></tr></table></figure></li></ul><h2 id="electron-国内源"><a href="#electron-国内源" class="headerlink" title="electron 国内源"></a>electron 国内源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># https://npmmirror.com/mirrors/electron/</span><br>npm config <span class="hljs-built_in">set</span> electron_mirror=https://npmmirror.com/mirrors/electron/<br>npm config <span class="hljs-built_in">set</span> electron_builder_binaries_mirror=https://npmmirror.com/mirrors/electron-builder-binaries/<br></code></pre></td></tr></table></figure><h2 id="镜像集合"><a href="#镜像集合" class="headerlink" title="镜像集合"></a>镜像集合</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># https://npmmirror.com/</span><br><span class="hljs-comment"># 开源镜像: https://npmmirror.com/mirrors/</span><br><span class="hljs-comment"># Node.js 镜像: https://npmmirror.com/mirrors/node/</span><br><span class="hljs-comment"># alinode 镜像: https://npmmirror.com/mirrors/alinode/</span><br><span class="hljs-comment"># ChromeDriver 镜像: https://npmmirror.com/mirrors/chromedriver/</span><br><span class="hljs-comment"># OperaDriver 镜像: https://npmmirror.com/mirrors/operadriver/</span><br><span class="hljs-comment"># Selenium 镜像: https://npmmirror.com/mirrors/selenium/</span><br><span class="hljs-comment"># electron 镜像: https://npmmirror.com/mirrors/electron/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>镜像</tag>
      
      <tag>国内源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2023/08/04/performance/"/>
    <url>/2023/08/04/performance/</url>
    
    <content type="html"><![CDATA[<p>性能优化的核心在于减少页面加载时间和提高用户体验</p><h2 id="Why-为什么需要性能优化"><a href="#Why-为什么需要性能优化" class="headerlink" title="Why-为什么需要性能优化"></a>Why-为什么需要性能优化</h2><p>性能优化在前端开发中非常重要，原因如下：</p><ol><li><p>提升用户体验：用户对于网页加载速度和响应性的要求越来越高。如果网页加载缓慢或响应不及时，用户可能会感到不耐烦，甚至选择离开。通过性能优化，可以加快网页的加载速度、提高响应性，提升用户体验，增加用户的留存和转化率。</p></li><li><p>提高页面可访问性：性能优化可以确保网页在不同网络环境和设备上都能快速加载和正确显示。对于网络条件较差或设备性能较低的用户，快速加载的网页可以提供更好的访问体验，降低用户的等待时间和流量消耗。</p></li><li><p>节省带宽和服务器资源：优化资源加载和压缩可以减少网页的文件大小和HTTP请求次数，从而节省带宽和服务器资源。这对于大流量网站来说尤为重要，可以降低服务器的负载，减少资源消耗和成本。</p></li><li><p>改善搜索引擎排名：搜索引擎对于网页加载速度的优化有一定的考量，加载速度较快的网页往往在搜索结果中排名更高。通过性能优化，可以提高网页的加载速度和性能表现，有助于改善搜索引擎的排名，增加网页的曝光和流量。</p></li><li><p>适应移动设备和低带宽环境：越来越多的用户使用移动设备访问网页，而移动设备的网络环境和性能有限。性能优化可以使网页适应不同的设备和网络环境，提供良好的移动端体验，满足用户的需求。</p></li></ol><p>综上所述，性能优化对于提升用户体验、节省资源、改善搜索排名和适应移动设备等方面都具有重要意义。它能够使网页加载更快、响应更快，提高用户满意度，增加网站的流量和转化率。</p><h2 id="What-前端性能优化究竟是什么"><a href="#What-前端性能优化究竟是什么" class="headerlink" title="What-前端性能优化究竟是什么"></a>What-前端性能优化究竟是什么</h2><p>性能优化是一种技术过程，通过一系列技术和策略来改善<code>前端</code>(网页或应用程序)的性能，以提高用户体验和效率，并解决以上问题。</p><h2 id="How-如何进行性能优化"><a href="#How-如何进行性能优化" class="headerlink" title="How-如何进行性能优化"></a>How-如何进行性能优化</h2><p>性能优化可以按照优化目的进行简单的分类</p><ol><li>资源下载速度<ol><li>减少源码包大小：<code>tree shaking</code>、<code>lazy load</code>，经常在打包工具的过程中进行优化</li><li>按优先度拆分资源包：将可以懒加载的资源从主包中拆分出来，降低主包的大小</li><li>服务器运用压缩技术：<code>Gzip</code>、<code>Br</code>等压缩</li><li><code>CDN</code>技术：运用<code>CDN</code>技术，将源码包部署到CDN服务器，加快资源的响应速度</li><li>充分利用缓存机制： 使用缓存可以减少请求开销，如使用 <code>Service Worker</code>，制定合理地 <code>HTTP Cache</code> 策略等</li></ol></li><li>渲染速度<ol><li>资源懒加载：图片、字体文件、字体图标等，可以按需加载</li><li>资源适配：根据机型适配合适大小的资源文件</li><li>避免频繁DOM操作：可以将多次的Dom操作合并，或者利用<code>Virtual DOM</code>技术</li></ol></li><li>执行速度<ol><li>减少不必要的计算和操作：避免进行不必要的计算和操作，尽量减少循环次数和条件判断。可以通过缓存计算结果、合并操作、使用短路运算符等方式来减少不必要的计算。</li><li>优化循环和迭代：循环是JavaScript中常见的性能瓶颈之一。可以使用更高效的循环方式，如使用for循环替代forEach、map等迭代方法。同时，在循环中避免频繁的DOM操作，可以将DOM操作移到循环外部或使用文档片段进行批量操作。</li><li>使用事件委托：对于需要处理大量相似元素的事件，可以使用事件委托的方式，将事件处理程序绑定到它们的父元素上，通过事件冒泡机制来处理事件。这样可以减少事件处理程序的数量，提高性能。</li><li>使用异步操作：对于耗时的操作，如网络请求、文件读写等，可以使用异步操作来避免阻塞主线程。可以使用Promise、async&#x2F;await、setTimeout等方式来进行异步操作。</li><li>使用Web Workers：对于需要进行大量计算或复杂操作的任务，可以考虑使用Web Workers。Web Workers可以在后台线程中执行任务，不会阻塞主线程，提高页面的响应性能。</li></ol></li></ol><h3 id="针对Vue框架的性能优化"><a href="#针对Vue框架的性能优化" class="headerlink" title="针对Vue框架的性能优化"></a>针对Vue框架的性能优化</h3><ol><li><p>升级到<code>Vue3</code>：<code>Vue3</code>在<code>diff算法</code>和<code>响应式</code>都进行了很大的性能优化，另外编程效率、团队协作效率在Vue也有很巨大的提升</p></li><li><p>缩小组件范围：在<code>Vue</code>应用程序中，组件是构建用户界面的基本单元。为了提高性能，可以尽量缩小组件的范围。将组件细分为更小的组件，避免不必要的重新渲染和更新。</p></li><li><p>合理使用计算属性和侦听器：计算属性和侦听器是Vue中用于处理响应式数据的机制。合理使用计算属性和侦听器可以避免不必要的计算和更新。确保计算属性是基于需要的响应式数据计算的，并避免在侦听器中执行复杂的操作。</p></li><li><p>合理使用<code>v-if</code>和<code>v-for</code>指令：<code>v-if</code>和<code>v-for</code>是<code>Vue</code>中常用的指令，用于条件渲染和列表渲染。在使用这些指令时，要注意避免在循环中使用<code>v-if</code>，因为它会导致不必要的重新渲染。可以考虑使用计算属性或过滤器来处理复杂的条件逻辑。</p></li><li><p>使用<code>Vue</code>的异步组件：<code>Vue</code>提供了异步组件的功能，可以延迟加载组件，提高初始渲染性能。可以将不常用或较大的组件设置为异步组件，只在需要时进行加载。</p></li><li><p>合理使用<code>keep-alive</code>组件：<code>keep-alive</code>组件可以缓存组件的状态，避免重复的创建和销毁。对于需要频繁切换的组件，可以使用<code>keep-alive</code>组件进行缓存，提高性能。</p></li><li><p>使用Vue的列表过渡和动画：<code>Vue</code>提供了列表过渡和动画的功能，可以为列表的插入、更新和删除操作添加过渡效果。合理使用这些过渡和动画可以提升用户体验，但要注意避免过多的动画效果影响性能。</p></li><li><p>懒加载路由和组件：对于大型的<code>Vue</code>应用程序，可以考虑使用懒加载路由和组件的方式。只在需要时加载路由和组件，减少初始加载的资源量。</p></li></ol><h3 id="针对Angular框架的性能优化"><a href="#针对Angular框架的性能优化" class="headerlink" title="针对Angular框架的性能优化"></a>针对Angular框架的性能优化</h3><ol><li><p>使用<code>AOT</code>编译：<code>Angular</code>提供了<code>AOT（Ahead-of-Time）</code>编译器，可以在构建时将模板编译为<code>JavaScript</code>代码。与<code>JIT（Just-in-Time）</code>编译相比，AOT编译可以减少应用程序的初始加载时间，并提高性能。</p></li><li><p>懒加载模块：对于大型的<code>Angular</code>应用程序，可以使用懒加载模块的方式延迟加载不必要的模块。只在需要时加载模块，可以减少初始加载的资源量，提高应用程序的加载速度。</p></li><li><p>使用轻量级的变更检测策略：<code>Angular</code>的变更检测机制是其性能的一个关键点。可以使用轻量级的变更检测策略，如OnPush策略，来减少变更检测的次数。在组件中设置<code>ChangeDetectionStrategy.OnPush</code>可以告诉<code>Angular</code>只在输入属性发生变化时才进行变更检测。</p></li><li><p>减少不必要的变更检测：在<code>Angular</code>应用程序中，避免在模板中使用复杂的表达式和函数调用，因为它们可能会触发不必要的变更检测。尽量将复杂的计算逻辑移到组件中，在需要时手动触发变更检测。</p></li><li><p>使用轻量级的<code>RxJS</code>操作符：<code>RxJS</code>是<code>Angular</code>中常用的响应式编程库。在使用<code>RxJS</code>时，尽量使用轻量级的操作符，如<code>map</code>、<code>filter</code>等，避免使用过多的操作符和复杂的管道，以减少性能开销。</p></li><li><p>避免频繁的<code>DOM操作</code>：频繁的<code>DOM操作</code>会影响性能。可以使用<code>Angular</code>的内置指令，如<code>ngIf</code>、<code>ngFor</code>等，来优化DOM操作。另外，可以使用<code>ng-container</code>来减少不必要的<code>DOM元素</code>嵌套。</p></li><li><p>使用轻量级的依赖注入：依赖注入是<code>Angular</code>的核心特性之一。在使用依赖注入时，尽量使用轻量级的服务和依赖项，避免注入过多的复杂对象和不必要的依赖。</p></li><li><p>使用<code>TrackBy</code>函数进行列表渲染优化：在使用<code>ngFor</code>指令进行列表渲染时，可以通过提供一个<code>TrackBy</code>函数来优化性能。TrackBy函数可以告诉<code>Angular</code>如何跟踪列表中的每个项的唯一标识，从而减少不必要的DOM操作。</p></li></ol><h3 id="针对React框架的性能优化"><a href="#针对React框架的性能优化" class="headerlink" title="针对React框架的性能优化"></a>针对React框架的性能优化</h3><ol><li><p>使用生产环境构建：在部署<code>React</code>应用程序时，使用生产环境构建可以进行代码压缩和优化，减少文件大小，提高加载速度。</p></li><li><p>使用<code>React.memo</code>进行组件记忆：<code>React.memo</code>是一个高阶组件，用于记忆组件的渲染结果。可以使用<code>React.memo</code>来避免不必要的组件重新渲染，提高性能。但要注意，<code>React.memo</code>只对组件的<code>props</code>进行浅比较，如果<code>props</code>包含复杂的对象或函数，可能需要额外的处理。</p></li><li><p>使用<code>React.lazy</code>和<code>Suspense</code>进行懒加载：<code>React.lazy</code>和<code>Suspense</code>是React提供的懒加载机制。可以将组件的加载延迟到需要时再进行，减少初始加载的资源量。使用<code>React.lazy</code>和<code>Suspense</code>可以实现按需加载组件，提高应用程序的性能。</p></li><li><p>使用<code>shouldComponentUpdate</code>或<code>React.memo</code>进行组件更新控制：在React中，可以使用<code>shouldComponentUpdate</code>生命周期方法或<code>React.memo</code>来控制组件的更新。通过实现自定义的<code>shouldComponentUpdate</code>方法或使用<code>React.memo</code>，可以避免不必要的组件重新渲染，提高性能。</p></li><li><p>使用<code>React.Fragment</code>减少不必要的DOM节点：在渲染组件时，可以使用<code>React.Fragment</code>来包裹多个子元素，以减少不必要的DOM节点。<code>React.Fragment</code>可以帮助优化DOM结构，提高渲染性能。</p></li><li><p>使用虚拟化列表：对于长列表或大数据集，可以使用虚拟化列表来渲染可见区域的内容。虚拟化列表只渲染当前可见的列表项，而不是全部渲染，从而减少DOM操作和提高性能。</p></li><li><p>使用轻量级的状态管理方案：对于中小型的React应用程序，可以考虑使用轻量级的状态管理方案，如<code>React Context</code>或<code>Redux Toolkit</code>。避免引入过多的状态管理库和复杂的状态管理逻辑，以减少性能开销。</p></li><li><p>使用性能优化工具和库：有许多第三方工具和库可用于优化React应用程序的性能，如<code>Webpack</code>的代码分割和懒加载插件、<code>React Router</code>的懒加载路由、<code>React.memo</code>的自定义比较函数等。根据具体的应用场景和需求，选择适合的工具和库进行性能优化。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端深入浅出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的事件循环机制</title>
    <link href="/2021/08/04/event-loop/"/>
    <url>/2021/08/04/event-loop/</url>
    
    <content type="html"><![CDATA[<p>事件循环机制的核心是一个事件循环线程，它持续运行并监听事件队列。当有事件需要处理时，事件循环会将事件从队列中取出并执行相应的回调函数</p><h2 id="Why-为什么需要事件循环机制"><a href="#Why-为什么需要事件循环机制" class="headerlink" title="Why-为什么需要事件循环机制"></a>Why-为什么需要事件循环机制</h2><p><code>JavaScript</code>是一种单线程的编程语言，意味着它一次只能执行一个任务。如果在执行一个耗时的操作时，如网络请求或计算密集型任务，如果<code>JavaScript</code>采用同步的方式执行，那么整个页面或应用程序将会被阻塞，用户无法进行其他操作，直到该任务完成。这会导致用户体验不佳，页面或应用程序的响应性能下降。</p><p>为了解决这个问题，<code>JavaScript</code>引入了事件循环机制。事件循环机制允许<code>JavaScript</code>在执行异步任务时，不必等待任务完成，而是继续执行后续的代码。它通过将异步任务放入任务队列中，并在主线程空闲时执行相应的回调函数，实现了非阻塞的异步执行。</p><p>具体来说，事件循环机制的好处包括：</p><ol><li>增强用户体验：通过使用事件循环机制，可以确保页面或应用程序的响应性能更高，用户可以在进行耗时操作时继续进行其他操作。</li><li>提高性能：通过将耗时的任务放入异步队列中，<code>JavaScript</code>可以继续执行其他任务，充分利用计算资源，提高整体性能。</li><li>处理事件和交互：事件循环机制使得<code>JavaScript</code>能够处理用户交互、事件监听和响应，例如点击事件、键盘事件和鼠标事件等。</li><li>支持异步操作：<code>JavaScript</code>中有许多常见的异步操作，如网络请求、文件读写和定时器等。事件循环机制使得这些异步操作可以以非阻塞的方式执行，提高代码的效率和可维护性。</li></ol><h2 id="What-事件循环究竟是什么"><a href="#What-事件循环究竟是什么" class="headerlink" title="What-事件循环究竟是什么"></a>What-事件循环究竟是什么</h2><p>在 JavaScript 中，异步任务可以分为<code>宏任务</code>和<code>微任务</code></p><p><code>宏任务</code>一般包括了以下几种：</p><ul><li><code>setTimeout</code> 和 <code>setInterval</code></li><li><code>I/O</code> 操作，如 <code>Ajax</code>、<code>文件读取</code>等</li><li><code>UI渲染</code>等</li></ul><p><code>微任务</code>一般包括以下几种：</p><ul><li><code>Promise.then()</code> 和 <code>catch()</code>方法</li><li><code>process.nextTick()</code></li><li><code>MutationObserver()</code>方法</li></ul><p><code>JavaScript</code> 中的事件循环机制由下面四个部分组成：</p><ol><li><p>调用堆栈(<code>Call Stack</code>)<br>调用堆栈记录了 <code>JavaScript</code> 代码的执行顺序。当代码开始执行时，会被顺序推入调用堆栈(<code>Call Stack</code>)，当函数执行完毕后，会从堆栈中弹出。由于 <code>JavaScript</code> 是单线程的，所以在调用堆栈中只能有一个任务在执行。在执行宏任务的过程中，如果遇到了微任务会将其加入微任务队列；</p></li><li><p>宏任务队列(<code>Task Queue</code>)<br>宏任务队列可以理解为存放宏任务的一个队列。当遇到宏任务时，它会被顺序加入到宏任务队列中。宏任务一般是异步任务，包括 <code>setTimeout</code> 、<code>setInterval</code>、<code>I/O 操作</code>等。只有当前的宏任务执行完毕之后，才会执行下一个宏任务。</p></li><li><p>微任务队列(<code>Microtask Queue</code>)<br>微任务队列也可以理解为存放微任务的一个队列。当遇到微任务时，它会被顺序加入到微任务队列中。在每个宏任务执行结束后，会检查微任务队列是否为空。如果不为空，就会执行微任务队列中的所有任务，直到微任务队列为空。</p></li><li><p>渲染队列(<code>Render Queue</code>)<br>渲染队列主要是用于浏览器中的渲染，保存了在执行宏任务期间发生的所有页面渲染操作，例如修改了 <code>DOM</code> 树中的节点内容。当宏任务执行完毕后，<code>JavaScript</code>引擎会检查是否需要更新页面，如果需要，则进行渲染，否则跳过这个步骤。</p></li></ol><h2 id="How-事件循环机制是如何执行的"><a href="#How-事件循环机制是如何执行的" class="headerlink" title="How-事件循环机制是如何执行的"></a>How-事件循环机制是如何执行的</h2><p>事件循环机制的执行过程可以分为以下几个步骤：</p><ol><li><p>执行同步代码：<code>JavaScript</code>首先会执行当前的同步代码，即按照顺序执行代码块中的语句，直到遇到异步任务或事件。</p></li><li><p>将异步任务放入任务队列：当遇到异步任务时，<code>JavaScript</code>会将其放入任务队列中，而不是立即执行。异步任务可以是定时器（<code>setTimeout</code>、<code>setInterval</code>）、网络请求（<code>Ajax</code>、<code>Fetch</code>）、<code>Promise</code>等。这些异步任务会在特定的条件满足后被触发执行。</p></li><li><p>监听事件队列：事件循环线程会持续监听事件队列，以检查是否有待处理的事件或异步任务。事件队列中存储了待处理的事件和异步任务。</p></li><li><p>执行事件处理或异步任务：当事件循环线程发现事件队列中有待处理的事件时，它会取出事件，并执行相应的事件处理函数。对于异步任务，当主线程空闲时，事件循环线程会从任务队列中取出任务，并执行相应的回调函数。</p></li><li><p>重复执行：一旦执行完一个事件处理或异步任务，事件循环线程会再次检查事件队列，看是否还有待处理的事件。如果有，它会继续执行下一个事件处理或异步任务。这个过程会一直重复，直到事件队列和任务队列都为空。</p></li></ol><p>需要注意的是，事件循环机制是单线程的，意味着同一时间只能执行一个任务。当事件循环线程执行事件处理或异步任务时，其他任务需要等待。这也是为什么长时间运行的任务可能会阻塞主线程，导致页面或应用程序的响应性能下降。</p><h2 id="Got-能从中收益什么"><a href="#Got-能从中收益什么" class="headerlink" title="Got-能从中收益什么"></a>Got-能从中收益什么</h2><p>通过事件循环机制，JavaScript能够以非阻塞的方式处理异步任务和事件，提高代码的执行效率和用户体验。了解事件循环机制的执行过程对于编写高效的异步代码非常重要，因为它可以帮助你理解代码执行的顺序和如何处理异步操作。</p>]]></content>
    
    
    <categories>
      
      <category>前端深入浅出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件循环</tag>
      
      <tag>EventLoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
